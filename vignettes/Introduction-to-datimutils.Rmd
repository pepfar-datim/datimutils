---
title: "Introduction-to-datimutils"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction-to-datimutils}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `datimutils` package was developed to simplify interaction with the DATIM/DHIS2 api from R. The package was designed to work well with `tidyverse` package functions and currently supports requesting metadata and metadata properties as well as aggregated data from the analytics resource of the API. This enables one to pull any data that one would be able to get in a DHIS2 pivot table.

To make use of `datimutils` package you should already have a basic understanding of DATIM/DHIS2. For instance you should understand that:

* the data in DHIS2 instances are associated with organisation units, data elements, time periods, and categories and category options such as age and sex;

* the metadata in DHIS2 have additional properties depending on the metadata type, for instance latitude and longitude for organisation units or description for data elements;

* organisation units are structured in a hierarchy and data can be aggregated within that hierarchy.

Below we will show how datimutils can be used to log into a DHIS2 instance, retrieve metadata, and retireve aggregated data for further analysis in R.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = T
)
```

```{r setup}
library(datimutils)
library(httptest)
```

```{r, include = FALSE}
httptest::start_vignette("play.dhis2.org")
```
## Logging into DATIM

Before querying the DATIM api, you must log into a DATIM instance. There are three basic ways to do so within datimutils. All three utilize the `loginToDATIM` function.

By default the `loginToDATIM` function will create an object containing details about the session. This object is named *d2_default_session*, and it is created in the environment from which the `loginToDATIM` function is called. In this vignette we are assuming you are logging in from the global environment. All datimutils functions will search for the d2_default_session by default, allowing you to make multiple DATIM api requests through datimutils without individually specifying unique login objects.

> Note: By default, this session will expire after 60 minutes. When it does, you will need to re-authenticate

### Method 1 - The Most Basic

The most basic method is to pass your username and password directly into the `loginToDATIM` function.

```{r eval = F}
loginToDATIM(
  base_url = 'play.dhis2.org/2.36/',
  username = 'admin',
  password = 'district'
)
```


### Methods 2 and 3 - Configuration Files

The other two methods require the use of a configuration file. Make sure that you remember the location of this config file, as you will need it to pass into the `loginToDATIM` function. If a user wants to ablility to quickly log into multiple different servers, they can have a config file for each one.

In this case, our config file is a JSON file called, *play.json*.

There are two ways to login with this config file.

In the first, you input your baseurl, username, and password.

```{r eval = F}
{
"dhis": {
  "baseurl": "play.dhis2.org/2.36/",
  "username": "admin",
  "password": "district"
}
}
```
Alternatively, if the the entry for password is blank such that the file looks like this
```{r eval = F}
{
"dhis": {
  "baseurl": "play.dhis2.org/2.36/",
  "username": "admin",
  "password": ""
}
}
```
The function will look in your keyring for the password, and if not found, will prompt you to enter a password and will store it automatically under that username and service (baseurl) for the next login. A user may prefer storing their passwords in their keyring because it allows them to avoid storing passwords in plain text on their computer, which is a potential security risk.   
>Note: keyrings operate differently on different operating systems


In both methods, call the `loginToDATIM` function as so:
> Note: replace `play.json` with the path of your config file

```{r}
# logging in generates a cookie so the other funcitons can be used freely without credentials
loginToDATIM(config_path = "play.json")
```

## Features for working with DATIM/DHIS2 metadata

For demonstration purposes, we will use a sample data set:

```{r}
data <- tibble::tribble(~dataElement, ~orgUnit, ~value,
                "fbfJHSPpUQD", "kJq2mPyFEHo", 1,
                "cYeuwXTCPkU", "kJq2mPyFEHo", 2,
                "fbfJHSPpUQD", "Vth0fbpFcsO", 3
                )
print(data)
```


### Getting metadata based on a vector of identifiers (e.g. uid or name)

A DHIS2 configuration includes many different types of metadata, such as data elements and indicators. The Web api lets you look up these pieces of metadata and obtain their related properties . For instance, a property of an organisation unit is its path. Datimutils provides a number of high level metadata helpers for obtaining details on the different types of metadata. This is the list of high level metadata helpers in datimutils.

```
getCategories(values, by, fields, d2_session, retry)

getCatCombos(values, by, fields, d2_session, retry)

getCatOptionCombos(values, by, fields, d2_session, retry)

getCatOptionGroupSets(values, by, fields, d2_session, retry)

getCatOptionGroups(values, by, fields, d2_session, retry)

getCatOptions(values, by, fields, d2_session, retry)

getDataElementGroupSets(values, by, fields, d2_session, retry)

getDataElementGroups(values, by, fields, d2_session, retry)

getDataElements(values, by, fields, d2_session, retry)

getDataSets(values, by, fields, d2_session, retry)

getIndicatorGroupSets(values, by, fields, d2_session, retry)

getIndicatorGroups(values, by, fields, d2_session, retry)

getIndicators(values, by, fields, d2_session, retry)

getOptionGroupSets(values, by, fields, d2_session, retry)

getOptionGroups(values, by, fields, d2_session, retry)

getOptionSets(values, by, fields, d2_session, retry)

getOptions(values, by, fields, d2_session, retry)

getOrgUnitGroupSets(values, by, fields, d2_session, retry)

getOrgUnitGroups(values, by, fields, d2_session, retry)

getOrgUnits(values, by, fields, d2_session, retry)

getDimensions(values, by, fields, d2_session, retry)
```

Additionally there is a generic getMetadata function that allows you to create more complex requests for metadata. We provide examples of using these metadata functions below.


#### Uuids to names

By default, `getDataElements` (and the other high level metadata helpers) support the conversion of a vector of uids into a vector of names. The command

```{r}
getOrgUnits(data$orgUnit)
```

would return `[1] "Kenema" "Kenema" "Kono" `, as the orgUnit uid "kJq2mPyFEHo" corresponds to the name "Kenema."

Note that you get a row for "Kenema" both times it appears. This is an advantage of datimutils. It will return the metadata jhelpers in the same order order of the vector passed in. Because of this, it works well with tidyverse functions like the one below.

```{r}
dplyr::mutate(data,
              dataElementName = datimutils::getDataElements(dataElement))

```

#### Names to uuids

It is also possible to look up metadata using a different identifier, but you must specify the field you intend to use.

```{r}
getOrgUnits('Bo', by = name)

# Return: [1] "O6uvpzGd5pu"
```

<!--
> Note: The name passed in the function can be written with single quotes (as seen above), with no quotes at all `getOrgUnits(Bo, by = name)`, but not with double quotes.

It seems that neither double quotes nor no quotes works. Single quotes is the only one I tested that worked.
-->

Identifiers besides 'name' could be 'shortName' or 'id.'

#### Working with metadata fields

The `getMetadata` function can be used to call metadata returning endpoints. It takes an endpoint and fields as its basic arguments. The main difference between `getMetadata` and other metadata helpers is that `getMetadata` does not require an array of values to query, meaning that you will not know the exact length of your response. This is disadvantageous for implementation in tidyverse functions like dplyer, but very beneficial if you want the full scope of information in a specific query.

```{r}
data <- getMetadata(
  end_point = "organisationUnits",
  "organisationUnitGroups.name:eq:District",
  fields = "id,name,level"
)

head(data)
```

In the above function, the second argument is called a filter. In this case, it filters the 'organisationUnits' endpoint to only respond with units at the district level.

To improve the syntax of datimutils code, datimutils has included it own api comparison operators. A full list of datimutils' custom api comparison operators can be found at the end of the section. The above and below command are equivalent.

```{r}
data <- getMetadata(
  end_point = "organisationUnits",
  organisationUnitGroups.name %.eq% "District",
  fields = "id,name,level"
)

head(data)
```

If you're familiar with the technology, datimutils also has non-standard evaluation:

```{r}
data <- getMetadata(
  end_point = organisationUnits,
  organisationUnitGroups.name %.eq% "District",
  fields = "id,name,level"
)

head(data)
```


Though the return of these commands may seem convoluted, as some columns actually lists, datimutils does an amazing job at organizing and presenting the queried data when compared to the query's raw JSON <!-- "This XML file does not appear to have any style information associated with it. The document tree is shown below."--> :
```
{
   "headers":[

   ],
   "metaData":{
      "items":{
         "FbKK4ofIv5R":{
            "uid":"FbKK4ofIv5R",
            "code":"IN_52494",
            "name":"Measles Coverage <1y",
            "legendSet":"BtxOoQuLyg1",
            "dimensionItemType":"INDICATOR",
            "valueType":"NUMBER",
            "totalAggregationType":"AVERAGE"
         },
         "JIVMtpjVZqJ":{
            "uid":"JIVMtpjVZqJ",
            "code":"IN_394153",
            "name":"Diarrhoea <5 y incidence rate (%)",
            "legendSet":"z9SVZTVo0j4",
            "dimensionItemType":"INDICATOR",
            "valueType":"NUMBER",
            "totalAggregationType":"AVERAGE"
         },
         "Tt5TAvdfdVK":{
            "uid":"Tt5TAvdfdVK",
            "code":"IN_52500",
            "name":"ANC LLITN coverage",
            "legendSet":"fqs276KXCXi",
            "dimensionItemType":"INDICATOR",
            "valueType":"NUMBER",
            "totalAggregationType":"AVERAGE"
         },
         "sB79w2hiLp8":{
            "uid":"sB79w2hiLp8",
            "name":"ANC 3 Coverage",
            "description":"Total 3rd ANC visits (Fixed and outreach) by expected number of pregnant women.",
            "legendSet":"fqs276KXCXi",
            "dimensionItemType":"INDICATOR",
            "valueType":"NUMBER",
            "totalAggregationType":"AVERAGE"
         },
         "sMTMkudvLCD":{
            "uid":"sMTMkudvLCD",
            "name":"HIV: testing and counseling 15-24y",
            "dimensionItemType":"INDICATOR",
            "valueType":"NUMBER",
            "totalAggregationType":"SUM"
         }
      }
   }
}
```
> Keep in mind that the above is ~1/20 of the total characters





<!-- seems like a new section from here on

These helpers will create repeated values and sorting based on input
```{r}
# make a random order and duplicated uid group
 groups <- rep(c(
    "gzcv65VyaGq", "uYxK4wmcPqA", "RXL3lPSK8oG"), 20)
 rows <- sample(length(groups))
 groups <- c("gzcv65VyaGq", "uYxK4wmcPqA", "RXL3lPSK8oG",
              groups[rows])

  data <-
    getOrgUnitGroups(
      groups,
      fields = "code,name,id")

# even though the actual api call only returns the 3 unique uids in a random
# order, the wrapper returns it in the order called.
str(data)
```



This is equivalent to:

```{r}
# notice the use of non-standard evaluation
data <- getMetadata(
  end_point = organisationUnits,
  organisationUnitGroups.name %.eq% "District",
  children.id %.in% c("YuQRtpLP10I","fwH9ipvXde9"),
  fields = "id,name,level"
)

head(data)
```

Data is usually returned in its most base class:
```{r}
# returns a vector
data <- getMetadata(
  end_point = "organisationUnitGroups",
  fields = "name"
)
print(data)
```

many different types of calls call be made, here we have two filters passed in as a vector. This call returns a nested data frame
```{r}
data <- getMetadata(
  end_point = "organisationUnits",
  c(
    "name:like:Baoma",
    "level:eq:3"
  ),
  fields = ":all"
)
str(data$translations)
```

There is a filter format helper for every comparison operator in Datim, here like is used.
```{r}
data <- getMetadata(
  end_point = "organisationUnits",
  name %.Like% "Sierra Leone"
)
```

-->
Here is a list of the api comparison operators and their datimutils equivalents:

```{r table2, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| DHIS2 Operator| infix operator  | Description                                     |
|---------------|:---------------:|------------------------------------------------:|
| eq            | %.eq%           | Equality                                        |
| !eq           | %.~eq%          | Inequality                                      |
| like          | %.Like%         | Case sensitive string, match anywhere           |
| !like         | %.~Like%        | Case sensitive string, not match anywhere       |
| \\$like       | %.^Like%       | Case sensitive string, match start             |
| !\\$like      | %.~^Like%      | Case sensitive string, not match start         |
| like\\$       | %.Like$%       | Case sensitive string, match end               |
| !like\\$      | %.~Like$%      | Case sensitive string, not match end           |
| ilike         | %.like%         | Case insensitive string, match anywhere         |
| !ilike        | %.~like%        | Case insensitive string, not match anywhere     |
| \\$ilike      | %.^like%       | Case insensitive string, match start           |
| !\\$ilike     | %.~^like%      | Case insensitive string, not match start       |
| ilike\\$      | %.like$%       | Case insensitive string, match end             |
| !ilike\\$     | %.~like$%      | Case insensitive string, not match end         |
| gt            | %.gt%           | Greater than                                    |
| ge            | %.ge%           | Greater than or equal                           |
| lt            | %.lt%           | Less than                                       |
| le            | %.le%           | Less than or equal                              |
| token         | %.token%        | Match on multiple tokens in search property     |
| !token        | %.~token%       | Not match on multiple tokens in search property |
| in            | %.in%           | Find objects matching 1 or more values          |
| !in           | %.~in%          | Find objects not matching 1 or more values      |
"
cat(tabl)
```

There is a analytics endpoint helper, `getAnalytics`. It takes arguments for dimensions and filters, and can also take any number of additional specifications as the first argument, which will get pasted on the end of the api call made. Here are some examples:

```{r}
#Get ANC: Key Coverages
#this call uses only dimension arguments, dx, ou, and pe
data <- getAnalytics("displayProperty=NAME",
dx = c("Uvn6LCg7dVU","OdiHJayrsKo","sB79w2hiLp8"), pe = c("THIS_YEAR"),
ou = c("ImspTQPwCqd"))

head(data)

#Get Infrastructure: Public facilities 2014 and 2013
#this call uses a filter ou argument, which are followed by _f
data <- getAnalytics("displayProperty=NAME",
dx = c("v27b2y9kKh7","vEBapQFZ1AA","DwEVHQvMnDZ"), pe = c("THIS_YEAR"),
ou_f = c("ImspTQPwCqd"))

head(data)
```

To use `getAnalytics` you can pass in the uids into their respective arguments and will be formatted correctly, but there are also two operators which can format strings for use in analytics api calls.

```{r}
a %.d% c("123","456")
a %.f% c("123","456")
httptest::end_vignette()
```
